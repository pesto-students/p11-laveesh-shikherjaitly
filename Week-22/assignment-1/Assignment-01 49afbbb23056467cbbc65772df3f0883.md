# Assignment-01

Created by: ShikhEr Jaitly
Created time: September 9, 2023 10:37 AM

- **Question 1: Normalization**
    
    Consider the following unnormalized table for a bookstore database:
    
    | Book ID | Title | Author | Genre | Publisher | ISBN | Price |
    | --- | --- | --- | --- | --- | --- | --- |
    | 101 | To Kill a Mockingbird | Harper Lee | Fiction | HarperCollins | 978-0061120084 | 10.99 |
    | 102 | The Great Gatsby | F. Scott Fitzgerald | Fiction | Scribner | 978-0743273565 | 12.50 |
    | 103 | Principles of Physics | Jearl Walker | Science | Wiley | 978-0321976444 | 50.00 |
    
    Normalize the table to 1NF, 2NF, and 3NF, explaining the steps you took at each normalization level.
    
    - 1NF
    
    | Book ID | Title | Author | Genre | Publisher | ISBN | Price |
    | --- | --- | --- | --- | --- | --- | --- |
    | 101 | To Kill a Mockingbird | Harper Lee | Fiction | HarperCollins | 978-0061120084 | 10.99 |
    | 102 | The Great Gatsby | F. Scott Fitzgerald | Fiction | Scribner | 978-0743273565 | 12.50 |
    | 103 | Principles of Physics | Jearl Walker | Science | Wiley | 978-0321976444 | 50.00 |
    - 2NF
    
    | Book ID | Title | Author | Publisher | ISBN | Price |
    | --- | --- | --- | --- | --- | --- |
    | 101 | To Kill a Mockingbird | Harper Lee | HarperCollins | 978-0061120084 | 10.99 |
    | 102 | The Great Gatsby | F. Scott Fitzgerald | Scribner | 978-0743273565 | 12.50 |
    | 103 | Principles of Physics | Jearl Walker | Wiley | 978-0321976444 | 50.00 |
    
    | Book ID | Genre |
    | --- | --- |
    | 101 | Fiction |
    | 102 | Fiction |
    | 103 | Science |
    
    Here, the book ID is the primary key
    
    As there can be multiple books with same genre, weâ€™ve separated the genre into another table.
    
    - 3NF
    
    | Book ID | Title | Author | Publisher |
    | --- | --- | --- | --- |
    | 101 | To Kill a Mockingbird | Harper Lee | HarperCollins |
    | 102 | The Great Gatsby | F. Scott Fitzgerald | Scribner |
    | 103 | Principles of Physics | Jearl Walker | Wiley |
    
    | Book ID | Genre |
    | --- | --- |
    | 101 | Fiction |
    | 102 | Fiction |
    | 103 | Science |
    
    | Publisher | ISBN | Price |
    | --- | --- | --- |
    | HarperCollins | 978-0061120084 | 10.99 |
    | Scribner | 978-0743273565 | 12.50 |
    | Wiley | 978-0321976444 | 50.00 |
    
- Question 2: Database Normalization Practice
    
    Apply Normalization on the below table and return the list of tables after 1NF, 2NF, 3NF, 4NF, 5NF( if applicable)
    
    ### Table: Employee Information
    
    | Employee ID | Employee Name | Department | Project ID | Project Name | Start Date | End Date | Salary |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    | 101 | John Doe | HR | 001 | Project A | 2023-01-15 | 2023-06-30 | 5000 |
    | 101 | John Doe | HR | 002 | Project B | 2023-04-01 | 2023-08-31 | 5200 |
    | 102 | Jane Smith | Marketing | 001 | Project A | 2023-02-01 | 2023-05-31 | 5500 |
    | 103 | Mike Johnson | IT | 002 | Project B | 2023-03-10 | 2023-08-15 | 6000 |
    | 103 | Mike Johnson | IT | 003 | Project C | 2023-06-15 | 2023-11-30 | 6200 |
    | 104 | Sarah Brown | HR | 002 | Project B | 2023-04-20 | 2023-07-31 | 4800 |
    | 105 | Robert Lee | Finance | 001 | Project A | 2023-05-05 | 2023-09-30 | 5200 |
    | 106 | Lisa Wang | IT | 001 | Project A | 2023-06-01 | 2023-12-31 | 5800 |
    
    - hint
        
        ### Step-by-Step Guidelines:
        
        ### Step 1: First Normal Form (1NF)
        
        Ensure each column contains atomic values. Eliminate repeating groups. Result: The table should not contain any repeating groups.
        
        ### Step 2: Second Normal Form (2NF)
        
        Identify the primary key(s). Eliminate partial dependencies. Result: The table should be in 2NF with separate tables for each entity and its attributes.
        
        ### Step 3: Third Normal Form (3NF)
        
        Remove transitive dependencies. Result: The table should be in 3NF with separate tables for each relationship.
        
        ### Step 4: Fourth Normal Form (4NF)
        
        Remove multi-valued dependencies. Result: The table should be in 4NF with separate tables for independent multi-valued attributes.
        
        ### Step 5: Fifth Normal Form (5NF) [If Applicable]
        
        Apply 5NF if the database has complex multi-valued relationships. In some cases, 5NF may not be necessary, as it applies to certain complex databases. If 5NF is applicable, it usually deals with cases of lossless-join decompositions.
        
        Note: The normalization process may involve additional steps and considerations depending on the complexity of the original table and the specific database design. Always aim to minimize redundancy, improve data integrity, and optimize the structure of the database.
        
    - 1NF
    
    | Employee ID | Employee Name | Department | Project ID | Project Name | Start Date | End Date | Salary |
    | --- | --- | --- | --- | --- | --- | --- | --- |
    | 101 | John Doe | HR | 001 | Project A | 2023-01-15 | 2023-06-30 | 5000 |
    | 101 | John Doe | HR | 002 | Project B | 2023-04-01 | 2023-08-31 | 5200 |
    | 102 | Jane Smith | Marketing | 001 | Project A | 2023-02-01 | 2023-05-31 | 5500 |
    | 103 | Mike Johnson | IT | 002 | Project B | 2023-03-10 | 2023-08-15 | 6000 |
    | 103 | Mike Johnson | IT | 003 | Project C | 2023-06-15 | 2023-11-30 | 6200 |
    | 104 | Sarah Brown | HR | 002 | Project B | 2023-04-20 | 2023-07-31 | 4800 |
    | 105 | Robert Lee | Finance | 001 | Project A | 2023-05-05 | 2023-09-30 | 5200 |
    | 106 | Lisa Wang | IT | 001 | Project A | 2023-06-01 | 2023-12-31 | 5800 |
    
    No change as the above can be can have a primary key that is a composite key of employee Id and project to create a unique primary key.
    
    - 2NF
    
    | Employee ID | Employee Name | Department |
    | --- | --- | --- |
    | 101 | John Doe | HR |
    | 102 | Jane Smith | Marketing |
    | 103 | Mike Johnson | IT |
    | 104 | Sarah Brown | HR |
    | 105 | Robert Lee | Finance |
    | 106 | Lisa Wang | IT |
    
    | Project ID | Project Name | Start Date | End Date |
    | --- | --- | --- | --- |
    | 001 | Project A | 2023-02-01 | 2023-05-31 |
    | 002 | Project B | 2023-04-01 | 2023-08-31 |
    | 003 | Project C | 2023-06-15 | 2023-11-30 |
    
    | Employee ID | Project ID | Salary |
    | --- | --- | --- |
    | 101 | 001 | 5000 |
    | 101 | 002 | 5200 |
    | 102 | 001 | 5500 |
    | 103 | 002 | 6000 |
    | 103 | 003 | 6200 |
    | 104 | 002 | 4800 |
    | 105 | 001 | 5200 |
    | 106 | 001 | 5800 |
    - 3NF
        
        
        | Employee ID | Employee Name | Department | Project ID | Project Name | Start Date | End Date | Salary |
        | --- | --- | --- | --- | --- | --- | --- | --- |
        | 101 | John Doe | HR | 001 | Project A | 2023-01-15 | 2023-06-30 | 5000 |
        | 101 | John Doe | HR | 002 | Project B | 2023-04-01 | 2023-08-31 | 5200 |
        | 102 | Jane Smith | Marketing | 001 | Project A | 2023-02-01 | 2023-05-31 | 5500 |
        | 103 | Mike Johnson | IT | 002 | Project B | 2023-03-10 | 2023-08-15 | 6000 |
        | 103 | Mike Johnson | IT | 003 | Project C | 2023-06-15 | 2023-11-30 | 6200 |
        | 104 | Sarah Brown | HR | 002 | Project B | 2023-04-20 | 2023-07-31 | 4800 |
        | 105 | Robert Lee | Finance | 001 | Project A | 2023-05-05 | 2023-09-30 | 5200 |
        | 106 | Lisa Wang | IT | 001 | Project A | 2023-06-01 | 2023-12-31 | 5800 |
        
        | Employee ID | Employee Name | Department |
        | --- | --- | --- |
        | 101 | John Doe | HR |
        | 102 | Jane Smith | Marketing |
        | 103 | Mike Johnson | IT |
        | 104 | Sarah Brown | HR |
        | 105 | Robert Lee | Finance |
        | 106 | Lisa Wang | IT |
        
        | Project ID | Project Name | Start Date | End Date |
        | --- | --- | --- | --- |
        | 001 | Project A | 2023-02-01 | 2023-05-31 |
        | 002 | Project B | 2023-04-01 | 2023-08-31 |
        | 003 | Project C | 2023-06-15 | 2023-11-30 |
        |  |  |  |  |
        
        | Employee ID | Project ID | Salary |
        | --- | --- | --- |
        | 101 | 001 | 5000 |
        | 101 | 002 | 5200 |
        | 102 | 001 | 5500 |
        | 103 | 002 | 6000 |
        | 103 | 003 | 6200 |
        | 104 | 002 | 4800 |
        | 105 | 001 | 5200 |
        | 106 | 001 | 5800 |
- **Question 3: What are the primary keys and foreign keys in a relational database, and how do they establish relationships between tables?**
    
    **Primary Keys:**
    
    - Primary keys are unique identifiers for each row in a relational database table.
    - They ensure that each row in the table has a distinct and unambiguous identification.
    - Primary keys cannot have null values, meaning every row must have a value in the primary key column.
    - They are used to enforce data integrity and maintain the uniqueness of records within the table.
    - A primary key can consist of one or multiple columns, known as a composite key when using multiple columns together.
    - It is typically defined when creating a table and is often automatically generated, like an auto-incrementing integer.
    
    **Foreign Keys:**
    
    - Foreign keys are columns in a table that establish relationships between that table and one or more other tables in the database.
    - They are used to ensure referential integrity, meaning that the data in the related tables remains consistent.
    - Foreign keys contain values that match the values in the primary key of another table, creating a link between the two tables.
    - The table with the foreign key is called the "child" table, and the table with the referenced primary key is called the "parent" table.
    - Foreign keys can be used to enforce constraints, such as ensuring that a value in the child table's foreign key column exists in the parent table's primary key column.
    - They enable the creation of relationships in the database schema, such as one-to-one, one-to-many, or many-to-many relationships.
- **Question 4: Explain the ACID properties in the context of database transactions.**
    
    ACID is an acronym that stands for Atomicity, Consistency, Isolation, and Durability. These properties are essential in the context of database transactions to ensure the reliability and integrity of data. Let's break down each of the ACID properties:
    
    1. **Atomicity:** This property ensures that a database transaction is treated as a single, indivisible unit of work. It means that all the operations within a transaction are either completed successfully, making all changes permanent, or none of them are completed if an error occurs. In other words, a transaction is atomic; it's like an "all or nothing" operation. If any part of the transaction fails, all changes made by that transaction are rolled back, ensuring data consistency.
    2. **Consistency:** The consistency property ensures that a database starts in a consistent state and ends in a consistent state after a transaction. In other words, a transaction should bring the database from one consistent state to another. If a transaction violates any integrity constraints (such as unique key constraints or referential integrity), it is rolled back, and the database remains unchanged.
    3. **Isolation:** Isolation refers to the concept that concurrent transactions should not interfere with each other. Each transaction should run in isolation from other transactions, as if it's the only transaction being executed. This ensures that the results of one transaction are not visible to other transactions until the transaction is completed. Various isolation levels (e.g., Read Uncommitted, Read Committed, Repeatable Read, Serializable) provide different levels of isolation, allowing you to balance between performance and data consistency based on your application's needs.
    4. **Durability:** Durability guarantees that once a transaction is committed (successfully completed), its effects on the database are permanent and will survive any subsequent system failures, including crashes or power outages. This is typically achieved by persistently storing the changes made by the transaction in non-volatile storage (e.g., hard disk) so that they can be recovered if needed during system recovery.
    
    In summary, the ACID properties are a set of guarantees that relational database management systems (RDBMS) provide to ensure the integrity and reliability of data during transactions. These properties help maintain data consistency, prevent data corruption, and allow for concurrent access to the database without compromising data integrity.
    
- **Question 5: Describe the concept of indexing in a database. How does indexing improve query performance?**
    
    Indexing in a database is a data structure that improves the speed of data retrieval operations on a database table. It acts as a reference or roadmap to the actual data stored in the table, allowing the database management system (DBMS) to quickly locate and access specific records based on the values in one or more columns. Here's how indexing works and how it improves query performance:
    
    **How Indexing Works:**
    
    1. **Data Structure**: An index is a separate data structure, typically stored in a B-tree or hash table format, that contains a sorted list of values from one or more columns of a database table.
    2. **Key-Value Mapping**: In the index, each entry consists of a value from the indexed column(s) and a pointer to the corresponding row in the table where that value is stored.
    3. **Sorted Order**: The values in the index are usually sorted in ascending or descending order, which makes it efficient to search for specific values using algorithms like binary search.
    4. **Maintenance**: Whenever data is inserted, updated, or deleted in the table, the index must be maintained to reflect these changes. This ensures that the index remains an accurate reference to the data.
    
    **How Indexing Improves Query Performance:**
    
    1. **Faster Data Retrieval**: When you execute a query that involves a column covered by an index, the DBMS can use the index to quickly identify the rows that match your query conditions. This is significantly faster than scanning the entire table.
    2. **Reduced I/O Operations**: Indexes reduce the number of I/O operations required to fetch data. Instead of reading the entire table, the DBMS reads only the relevant portions of the index and then retrieves the corresponding rows from the table.
    3. **Support for Sorting and Filtering**: Indexes are particularly useful for sorting and filtering operations. For example, if you need to retrieve records in a sorted order based on an indexed column, the DBMS can utilize the index to avoid sorting the entire dataset.
    4. **Join Optimization**: In cases where multiple tables are involved in a query with JOIN operations, indexes on the columns used for joining can significantly speed up the process. The DBMS can use these indexes to find matching rows efficiently.
    5. **Constraint Enforcement**: Indexes can be used to enforce constraints such as unique constraints or primary key constraints. This ensures data integrity and prevents duplicate or incorrect data from being inserted.
    6. **Covering Indexes**: Some indexes are designed to cover specific queries entirely, meaning that all the data needed to satisfy a query is available in the index itself. This eliminates the need to access the underlying table, further improving query performance.
    
    However, it's important to note that while indexing greatly enhances query performance, it comes with trade-offs. Indexes consume storage space, and maintaining them incurs overhead during data modification operations (inserts, updates, and deletes). Therefore, careful planning and consideration of which columns to index are crucial to strike a balance between query performance and overall system efficiency. Over-indexing or poorly designed indexes can lead to increased storage requirements and slower write operations.
    
- **Question 6: Explain the concept of concurrency control, deadlocks in a multi-user database environment.**
    
    Concurrency control and deadlocks are essential concepts in a multi-user database environment where multiple users or transactions concurrently access and modify the database. These mechanisms ensure data consistency and prevent conflicts that can arise when multiple transactions operate on the same data simultaneously.
    
    **1. Concurrency Control:**
    
    Concurrency control is a set of techniques and mechanisms used to manage the concurrent execution of multiple transactions in a way that ensures the integrity and consistency of the database. It prevents problems such as data corruption, lost updates, and inconsistent query results. Here are some key aspects of concurrency control:
    
    - **Isolation Levels:** Databases often provide different isolation levels (e.g., Read Uncommitted, Read Committed, Repeatable Read, Serializable) that define the degree of isolation between concurrent transactions. These levels determine whether a transaction can see uncommitted changes made by other transactions.
    - **Locking:** Locks are used to restrict access to data while a transaction is operating on it. There are two primary types of locks:
        - **Shared Lock (S-lock):** Allows multiple transactions to read the same data simultaneously but prevents any of them from modifying it.
        - **Exclusive Lock (X-lock):** Grants exclusive access to a single transaction, preventing other transactions from reading or modifying the data until the lock is released.
    - **Timestamps:** Some systems use timestamps or version numbers to track the order of transactions and resolve conflicts. Transactions are assigned timestamps, and data items are marked with timestamps or version numbers. Conflicts are resolved by comparing timestamps.
    
    **2. Deadlocks:**
    
    A deadlock is a situation where two or more transactions or processes are unable to proceed because each is waiting for a resource held by the other(s). In the context of a multi-user database environment, a deadlock occurs when two or more transactions are in a circular waiting state, where each transaction is waiting for a resource held by another transaction in the cycle. Deadlocks can lead to system slowdowns or even a complete standstill. Here are some key concepts related to deadlocks:
    
    - **Resource Types:** In a database environment, resources typically refer to locks on data items, database tables, or other objects. Transactions request and hold these resources.
    - **Deadlock Detection:** Systems use algorithms to detect deadlocks when they occur. One common approach is to construct a "wait-for" graph, where transactions are nodes, and edges represent dependencies between transactions. If a cycle is detected in this graph, a deadlock is present.
    - **Deadlock Resolution:** Once a deadlock is detected, it needs to be resolved. There are several common approaches to deadlock resolution, including:
        - **Kill a Transaction:** One of the involved transactions is aborted to break the deadlock. The aborted transaction's work is rolled back.
        - **Wait-Die and Wound-Wait Schemes:** These schemes determine which transaction is allowed to proceed and which is aborted based on priorities or timestamps.
        - **Timeouts:** Transactions are given a certain amount of time to acquire required resources. If they cannot obtain the resources within that time, they are rolled back.
    
    Concurrency control and deadlock management are crucial for maintaining database integrity and ensuring that multiple users can access and modify data concurrently without compromising consistency. Implementing these mechanisms effectively is a complex but essential part of database management systems.
    
- **Question 7: Read about Database sharding and explain couple of real time examples where, why, how it this concept is used.**
    
    Database sharding is a database architecture technique used to distribute and partition data across multiple database instances or servers, called shards, to improve performance, scalability, and availability. Each shard is responsible for a subset of the data, and this distribution allows for horizontal scaling as opposed to vertical scaling where you increase the resources of a single database server. Here are a couple of real-time examples of when and why database sharding is used:
    
    1. **Social Media Platforms**:
        - **Example**: Facebook, Twitter, Instagram
        - **Why**:
            - Social media platforms generate massive amounts of data every second, including user posts, comments, likes, and more.
            - Sharding allows these platforms to distribute user data across multiple database servers based on criteria such as user IDs or geographic regions.
            - As the user base grows, new shards can be added to accommodate the increasing data volume and maintain low latency for user interactions.
            - It helps maintain high availability and reduce the risk of outages because issues with one shard don't affect the entire platform.
    2. **E-commerce Websites**:
        - **Example**: Amazon, eBay, Alibaba
        - **Why**:
            - E-commerce sites handle extensive product catalogs, customer orders, and user data.
            - Sharding helps distribute product data across multiple database servers, and customer data can be sharded based on geographic regions.
            - During high-traffic events like Black Friday sales, the system can handle increased load by adding more database shards, ensuring smooth user experiences.
            - Sharding can also be used for data localization, complying with data privacy regulations in various regions.
    3. **Gaming Industry**:
        - **Example**: Online multiplayer games like Fortnite, World of Warcraft
        - **Why**:
            - Online games require real-time interaction and low-latency data retrieval for thousands or millions of players.
            - Sharding is used to distribute player data, game states, and interactions across multiple servers or clusters.
            - Each shard may represent a game world or a set of players, and it ensures that players interact primarily with others in the same shard, reducing latency.
            - As new players join, they are assigned to available shards, and more shards can be added to accommodate player growth.
    4. **Financial Services**:
        - **Example**: Stock trading platforms, banking systems
        - **Why**:
            - Financial systems deal with vast volumes of transactional data, and performance and data integrity are critical.
            - Sharding helps isolate and distribute data for specific clients or accounts to avoid contention and ensure responsiveness.
            - It can also be used for disaster recovery and failover strategies, where each shard may represent a separate data center.
            - Sharding allows financial systems to scale horizontally while maintaining transaction consistency and data security.
    
    In all these examples, database sharding is used to address scalability challenges, improve performance, and enhance availability while efficiently managing large volumes of data. Sharding strategies can vary, from range-based sharding (based on data ranges like user IDs or timestamps) to hash-based sharding (using a hash function to determine shard placement). Implementing and managing sharding requires careful planning and consideration of data distribution, failover mechanisms, and data migration strategies.